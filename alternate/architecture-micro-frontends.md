# Архитектура: Микро-фронтенды

_April 5, 2024_

Архитектура микро-фронтендов представляет собой подход к разработке веб-приложений, при котором фронтенд (клиентская часть) разбивается на независимые модули или компоненты (например, боковая панель, футер, виджет). Каждый из этих модулей может быть разработан, развернут и масштабирован независимо от остальных частей приложения.

Микро-фронтенды очень похожи на другой вариант архитектуры программного обеспечения – [микросервисы](https://en.wikipedia.org/wiki/Microservices). Оба подхода стремятся к модульности и независимости компонентов системы. Также они позволяют командам разработчиков работать над разными частями приложения параллельно, используя разные технологии и фреймворки, что увеличивает гибкость и скорость разработки. Микро-фронтенды и микросервисы обеспечивают независимость и изоляцию компонентов, что упрощает масштабирование и поддержку сложных систем.

После того как мы определили, что такое микро-фронтенды, рассмотрим предпосылки, которые привели к появлению и развитию этого подхода. Это поможет лучше понять, почему микро-фронтенды стали актуальным решением для современных веб-разработчиков

## Предпосылки для развития микро-фронтендов

### Рост сложности приложений

Рынок постоянно увеличивает требования к скорости, безопасности, удобству пользовательского интерфейса и функциональным возможностям веб-приложений, что приводит к необходимости их непрерывного улучшения и обновления.

Разработчики браузеров регулярно представляют новые API, расширяющие возможности веб-приложений, включая улучшения производительности, доступа к аппаратным функциям устройств и т.д.

Функциональность веб-приложений постепенно перемещается в сторону клиентской части, что обусловлено стремлением улучшить пользовательский опыт и сократить нагрузку на серверы. Это включает в себя:

* Использование AJAX для асинхронных запросов к серверу без необходимости перезагрузки всей страницы.
* Реализацию роутинга на стороне клиента для управления навигацией без обращения к серверу.
* Динамическую генерацию HTML-разметки на стороне клиента для более гибкого управления содержимым страницы.
* Перемещение бизнес-логики из бэкенда во фронтенд для быстрого реагирования на действия пользователя.
* Разработку механизмов кеширования на клиентской стороне для ускорения загрузки ресурсов и экономии трафика.
* Внедрение функций работы веб-приложений в офлайн-режиме для обеспечения доступности в условиях нестабильного интернет-соединения или его отсутствия.

### Обновление стека

Внедрение новой логики в клиентскую часть приложения приводит к возникновению новых технических проблем и вызовов, которые требуют разработки новых подходов к их решению.

Разработчики постоянно ищут и внедряют новые паттерны проектирования, фреймворки и библиотеки для решения проблем, возникающих в результате изменений в технологическом ландшафте и требованиях бизнеса.

Для поддержания веб-приложения актуальным, соответствующим современным стандартам и требованиям пользователей, необходимо регулярно обновлять используемые технологии и инструменты разработки.

Обновление монолитной кодовой базы веб-приложения моментально или за очень короткий промежуток времени чревато серьезными затратами времени и ресурсов, а также может привести к сложностям в обеспечении стабильности работы приложения и его отдельных компонентов.

### Работа команды

Рост кодовой базы и функционала требует увеличения количества инженеров для ее поддержки, что влечет за собой необходимость в более тщательном планировании ресурсов и координации между членами команды для обеспечения бесперебойности разработки и поддержки проекта.

Чем больше инженеров, тем сложнее коммуникация в команде. Инженеры не могут действовать независимо и должны договариваться друг с другом о влиянии одних частей на другие, что подразумевает наличие четких интерфейсов взаимодействия между модулями и компонентами системы, а также регулярное проведение совместных совещаний и ревью кода для обеспечения согласованности архитектурных решений и избежания конфликтов при интеграции разных частей проекта.

### Поддержка

Наличие большой и цельной кодовой базы, зависящей от одного технологического стека, затрудняет процесс внесения изменений, а также требует более тщательного тестирования и усиленной поддержки в процессе эксплуатации вследствие высокой степени взаимосвязи компонентов и модулей системы.

Изменения, производимые в одной части монолитного веб-приложения, могут непредсказуемо повлиять на функционирование его других частей, что увеличивает риски возникновения ошибок и сбоев в работе приложения в целом и требует от разработчиков более пристального внимания к вопросам контроля качества и тестирования.

Отсутствие модульности и высокая степень взаимозависимости компонентов монолитного приложения приводит к необходимости проведения обширных и времязатратных тестов всего приложения при каждом внесении изменений, что замедляет процесс разработки и доставки новых функциональных возможностей пользователям.

### Дублирование кода

Если бизнес владеет большим количеством продуктов, у них может быть необходимость использовать похожий функционал в нескольких продуктах.

В случае монолитных веб-приложений это приведет к дублированию функционала и удорожанию разработки, поскольку придется тратить время и ресурсы на реализацию, тестирование и поддержку одинакового кода в разных местах, что увеличивает вероятность ошибок и затрудняет внесение изменений и обновлений.

## Преимущества

### Независимые кодовые базы

Сокращение общего объема кода упрощает его понимание, поддержку и обновление.

Небольшие независимые кодовые базы позволяют инкапсулировать данные и бизнес-логику, и таким образом скрыть детали реализации определенного набора функциональностей в пределах отдельного сервиса. Это исключает или минимизирует неуместные зависимости между разными частями системы, что обеспечивает более простую модернизацию и обновление.

Меньшее количества кода облегчает проведение тестирования, поскольку требуется проверить меньшее количество функциональности, что уменьшает время на разработку и повышает качество тестов.

### Независимое развертывание

Независимое развертывание сокращает риски при внедрении обновлений для отдельных компонентов системы, поскольку обновления распространяются атомарно и не затрагивают работу всей системы, минимизируя вероятность возникновения ошибок.

Независимость процессов развертывания для отдельных элементов системы от общих циклов релиза приложения ускоряет доставку новых функций и улучшений до конечного пользователя, повышая отзывчивость и гибкость разработки.

### Независимые технологии

Каждая часть системы может быть разработана, используя индивидуально подобранные технологии и архитектурные решения, что позволяет достигать максимальной эффективности и оптимизации каждого конкретного модуля.

Принятие архитектурных и технологических решений для каждого компонента в отдельности обеспечивает удобство обновления и масштабирования каждого из них без риска нарушения функционала или производительности других частей системы. Таким образом, модификация одного модуля не влечет за собой необходимости вносить изменения в другие модули, что значительно упрощает процесс поддержки и развития приложения.

### Независимые команды

Небольшие команды, сформированные вокруг конкретных бизнес-функциональностей, имеют возможность глубоко погружаться в специфику разрабатываемого продукта, что обеспечивает высокий уровень ответственности за итоговый результат их работы и стимулирует поиск наилучших путей достижения цели.

Коммуникация внутри небольших команд и между разными командами играет ключевую роль в успешной разработке продукта, и независимые команды обладают здесь значительными преимуществами в виде гибкости коммуникационных процессов. Взаимодействие в рамках команды и с другими группами становится более эффективным и направленным, благодаря чему ускоряется принятие решений, улучшается координация, а возникающие проблемы решаются быстрее.

Возможность выбора методологии, оптимально подходящей для работы над конкретным проектом или его частью, позволяет командам максимально гибко подходить к процессу разработки. Каждая команда может индивидуально подбирать и комбинировать наиболее эффективные практики и инструменты управления проектами, ориентируясь на собственный опыт, специфику задач и предпочтения, что в совокупности повышает общую продуктивность и качество разрабатываемых продуктов.

## Типы архитектуры

### Вертикальная архитектура

Вертикальная архитектура микро-фронтендов подразумевает разделение приложения на несколько независимых разделов, каждый из которых разрабатывается, тестируется и развертывается независимо. Такой подход позволяет командам заниматься отдельными функциональными блоками или страницами приложения.

![Вертикальная архитектура](https://i.imgur.com/HEueGql.png)

### Горизонтальная архитектура

Горизонтальная архитектура микро-фронтендов это подход к разработке веб-приложений, при котором функциональные элементы (виджеты) разрабатываются, тестируются и развертываются независимо друг от друга и могут отображаться на одной и той же странице. Это позволяет различным командам работать над одной страницей параллельно.

![Горизонтальная архитектура](https://i.imgur.com/x28rxo6.png)

## Типы интеграции

Объединение микро-фронтендов в общую систему возможно на следующих этапах жизненного цикла:

* При сборке приложения.
* На клиенте во время выполнения.
* На сервере во время выполнения.

### На клиенте

#### Встраивание через iframe

Микро-приложение встраивается в хост-приложение через iframe.

```html
<html>
  <head>
    <title>Main page</title>
  </head>
  <body>
    <header>...</header>
    <iframe src="https://currency.example.app/widget"></iframe>
    <iframe src="https://weather.example.app/widget"></iframe>
    <footer>...</footer>
  </body>
</html>
```

Особенности работы с iframe:

* Обеспечивается изоляции из коробки, нет необходимости изоляции стилей, хост-приложение не имеет доступа к данным и DOM внутри iframe.
* Возможно установить строгие правила для источников контента, скриптов и других ресурсов внутри iframe (напрмер, [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)) для защиты от атак вроде XSS и инъекций.
* Сложная коммуникация между хостом и встраиваемым приложением через [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).
* Контент, загруженный внутри iframe, обычно не индексируется поисковыми системами, что может негативно сказаться на SEO.

#### Встраивание через JavaScript

В этом случае отдельно загружается скрипт микро-приложения и встраивается через собственный JavaScript интерфейс.

```html
<html>
  <head>
    <title>Main page</title>
  </head>
  <body>
    <header>...</header>
    <main>...</main>
    <div id="currency"></div>
    <footer>...</footer>
    <script src="https://currency.example.app/widget.js"></script>
    <script>
      const widget = new Currency({
        element: document.querySelector('#currency')
      })
      // widget ready to use
    </script>
  </body>
</html>
```

Таким же образом, возможно встраивать это универсальное микро-приложение в куда угодно, например в React-приложение при генерации разметки на клиенте.

```tsx
import React, {useRef, useEffect} from 'react'
import {Header, Footer} from 'components'

const commentsPromise = cache(() => import('https://comments.example.app/widget.js'))

export function MainPage() {
  const commentsRoot = useRef()

  useEffect(() => {
    commentsPromise.then((Comments) => {
      const widget = new Comments({
        element: commentsRoot.current,
        appId: 123
      })
      // widget ready to use
    })
  }, [])

  return (
    <>
      <Header />
      <main>...</main>
      <div ref={commentsRoot} />
      <Footer />
    </>
  )
}
```

В случае с более узким стеком, микро-приложение само может быть написано на React (federated React-компонент) и встраиваться в другое React-приложение.

```tsx
import React, {lazy} from 'react'
import {Header, Footer} from 'components'

const Comments = lazy(() => import('https://comments.example.app/widget.js'))

export function MainPage() {
  return (
    <>
      <Header />
      <main>...</main>
      <Comments appId={123} />
      <Footer />
    </>
  )
}
```

Особенности встраивания через JavaScript:

* Скрипты и стили выполняются в окружение хост-приложения.
* Необходима изоляция стилей.
* Любые скрипты хост-приложения имеют доступ к контенту и данным микро-приложения, что может привести к утечке пользовательских данных.
* Сложно настроить политики безопасности из-за того, что хост-приложение и микро-приложения исполняются в одном контексте.
* Простая коммуникация через события и JavaScript интерфейс.

#### Комбинированное встраивание

Предыдущие способы встраивания имеют свои преимущества и недостатки. Чтобы немного уменьшить недостатки, можно совместить эти два способа – непосредственное встраивание осуществлять через JavaScript интерфейс, который внутри себя будет встраивать микро-приложение через iframe.

```html
<html>
  <head>
    <title>Main page</title>
  </head>
  <body>
    <header>...</header>
    <main>...</main>
    <div id="comments">
      <!-- добавляется динамически при создании инстанса Comments -->
      <div class="comments-container">
        <iframe src="https://comments.example.app/widget/iframe?appId=123"></iframe>
      </div>
      <!-- / -->
    </div>
    <footer>...</footer>
    <script src="https://comments.example.app/widget.js"></script>
    <script>
      const widget = new Comments({
        element: document.querySelector('#comments'),
        appId: 123
      })
      // widget ready to use
    </script>
  </body>
</html>
```

Особенности комбинированного способа:

* Внутренний iframe обеспечивает изоляцию стилей и скриптов, предотвращая доступ сервиса к контенту и данным микро-приложения и наоборот.
* Возможно установить строгие политики безопасности для контента внутри iframe
* Внешний JavaScript интерфейс позволяет инкапсулировать транспорт между контекстами, что упрощает коммуникацию хост-приложения с микро-приложением внутри iframe, хост-приложению не нужно ничего знать про внутреннюю реализацию.

#### Custom Elements

Этот способ похож на встраивание через JavaScript интерфейс, но производится через нативные [Custom Elements](https://developer.mozilla.org/en-US/docs/Web/API/Web_Components/Using_custom_elements).

```html
<html>
  <head>
    <title>Main page</title>
  </head>
  <body>
    <header>...</header>
    <currency-widget></currency-widget>
    <weather-widget></weather-widget>
    <footer>...</footer>
    <script src="https://currency.example.app/widget.js"></script>
    <script src="https://weather.example.app/widget.js"></script>
  </body>
</html>
```

Особенности работы с Custom Elements:

* Обеспечивают изоляцию стилей и скриптов, предотвращая конфликты и упрощая интеграцию.
* Могут возникать сложности при коммуникации между пользовательскими элементами и хост-приложением, так как единственный возможный способ общения – через события.
* Контент, динамически генерируемый пользовательскими элементами, может не полностью индексироваться поисковыми системами.

### При сборке

#### Модули NPM или других хранилищ артефактов

Микро-приложение встраивается через JavaScript интерфейс, но вместо загрузки внешнего скрипта, использются установленные модули из хранилищ артефактов.

```tsx
import React, {useRef, useEffect} from 'react'
import {Header, Footer} from 'components'
import {Comments} from '@widgets/comments'

export function MainPage() {
  const commentsRoot = useRef()

  useEffect(() => {
    const widget = new Comments({
      element: commentsRoot.current,
      appId: 123
    })
    // widget ready to use
  }, [])

  return (
    <>
      <Header />
      <main>...</main>
      <div ref={commentsRoot} />
      <Footer />
    </>
  )
}
```

Микро-приложение может использовать тот же стек, что и хост-приложение.

```tsx
import React from 'react'
import {Header, Footer} from 'components'
import {Currency} from '@widgets/currency'
import {Weather} from '@widgets/weather'

export function MainPage() {
  return (
    <>
      <Header />
      <Currency />
      <Weather />
      <Footer />
    </>
  )
}
```

Особенности встраивания при сборке:

* Невозможно сквозное обновление микро-приложений, необходимо выпускать новый релиз хост-приложения для обновления подключаемых модулей.
* Код модуля фактически включается в сборку хост-приложения, что увеличивает ее размер и может ухудшить производительность.

### На сервере

#### При роутинге

На сервере несколько микро-приложений объединяются по локейшнам.

```nginx
server {
  ...

  location /search {
    proxy_pass https://search.example.app;
  }

  location /order {
    proxy_pass https://order.example.app;
  }

  ...
}
```

Подходит только для вертикальной архитектуры, где отдельные разделы веб-приложения являются микро-фронтендами.

#### При генерации разметки на сервере

Разметка микро-приложения встраивается в код страницы хост-приложения при рендере шаблона на сервере через [Server Side Includes](https://en.wikipedia.org/wiki/Server_Side_Includes).

```html
<html>
  <head>
    <title>Main page</title>
  </head>
  <body>
    <header>...</header>
    <!--# include file="https://currency.example.app" -->
    <!--# include file="https://weather.example.app" -->
    <footer>...</footer>
  </body>
</html>
```

Также возможно встраивать разметку при использовании любого стека, например в серверных компонентах React.

```tsx
import React from 'react'
import {Header, Footer} from 'components'

export async function MainPage() {
  const commentsMarkup = await fetchMarkup('https://comments.example.app/ssr?appId=123')
  return (
    <>
      <Header />
      <main>...</main>
      <div dangerouslySetInnerHTML={{__html: commentsMarkup}} />
      <Footer />
    </>
  )
}
```

И также микро-приложение может иметь тот же стек, что и хост-приложение.

```tsx
import React from 'react'
import {Header, Footer} from 'components'

export async function MainPage() {
  const Comments = await cache(() => import('https://comments.example.app/widget.js'))
  return (
    <>
      <Header />
      <main>...</main>
      <Comments appId={123} />
      <Footer />
    </>
  )
}
```

Особенности встраивания при генерации разметки на сервере:

* Разметка подготавливается на сервере и индексируется поисковыми системами.
* Скрипты и стили выполняются в окружении хост-приложения, поэтому необходима изоляция стилей.
* Любые скрипты хост-приложения могут получить доступ к контенту и данным микро-приложения, что может привести к утечке пользовательских данных.

## Коммуникация

Коммуникация между микро-приложениями имеет несколько особенностей и ограничений:

* Микро-фронтенды должны быть разработаны таким образом, чтобы быть максимально изолированными друг от друга, поэтому они не должны использовать общее состояние.
* Однако это также означает, что любая коммуникация между микро-фронтендами должна происходить по существующему контракту обмена данными. Cледует уделить внимание созданию надежного и масштабируемого API для взаимодействия между различными компонентами.

### Способы коммуникации

#### GET параметры URL

Данные необходимые для инициализации передаются GET параметрами в URL микро-приложения. Такой подход обычно применяется при встраивании через iframe.

```html
<html>
  <head>
    <title>Main page</title>
  </head>
  <body>
    <header>...</header>
    <main>...</main>
    <iframe src="https://comments.example.app/widget?appId=123"></iframe>
    <footer>...</footer>
  </body>
</html>
```

#### Сообщения

Микро-приложения общаются посредством [`MessageEvent`](https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent), отправляют данные через [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) и слушают событие [`message`](https://developer.mozilla.org/en-US/docs/Web/API/Window/message_event) для получения данных. Также применяется при встраивании через iframe.

```html
<html>
  <head>
    <title>Main page</title>
  </head>
  <body>
    <header>...</header>
    <main>...</main>
    <iframe id="comments" src="https://comments.example.app/widget"></iframe>
    <footer>...</footer>
    <script>
      const {contentWindow} = document.querySelector('#comments')
      window.addEventListener('message', (event) => {
        if (event.data.type === 'ready') {
          // widget ready to use
        }
      })
      contentWindow.postMessage({type: 'init', appId: 123}, '*')
    </script>
  </body>
</html>
```

#### JavaScript интерфейс

Встраиваемое микро-приложение обеспечивает внешний JavaScript интерфейс, методы которого вызывает хост-приложение для синхронизации данных. Внешний JavaScript интерфейс упрощает коммуникацию хост-приложения с микро-приложением, хост-приложение ничего не знает про его внутреннюю реализацию.

```html
<html>
  <head>
    <title>Main page</title>
  </head>
  <body>
    <header>...</header>
    <main>...</main>
    <div id="comments"></div>
    <footer>...</footer>
    <script src="https://comments.example.app/widget.js"></script>
    <script>
      const widget = new Comments({
        element: document.querySelector('#comments')
      })
      widget.init({appId: 123})
    </script>
  </body>
</html>
```

#### Шина событий

Встраиваемое микро-приложение обеспечивает внешний JavaScript интерфейса, который наследует абстрактный [EventEmitter](https://nodejs.org/api/events.html#class-eventemitter). При этом, возможно использовать шину событий совместно с собственными методами JavaScript интерфейса для упрощения коммуникации, например вызывать методы для передачи данных в микро-приложение и слушать события для отслеживания изменений состояния.

```html
<html>
  <head>
    <title>Main page</title>
  </head>
  <body>
    <header>...</header>
    <main>...</main>
    <div id="comments"></div>
    <footer>...</footer>
    <script src="https://comments.example.app/widget.js"></script>
    <script>
      const widget = new Comments({
        element: document.querySelector('#comments')
      })
      widget.on('ready', () => {
        // widget ready to use
      })
      widget.emit('init', {appId: 123})
    </script>
  </body>
</html>
```

#### Custom Events

Такой способ близок к шине событий, но реализуется через встроенный [`CustomEvent` API](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent). Это единственный способ коммуникации при встраивании микро-приложения через Custom Elements наряду с атрибутами HTML-элементов.

```html
<html>
  <head>
    <title>Main page</title>
  </head>
  <body>
    <header>...</header>
    <main>...</main>
    <comments-widget></comments-widget>
    <footer>...</footer>
    <script src="https://comments.example.app/widget.js"></script>
    <script>
      const commentsRoot = document.querySelector('comments-widget')
      commentsRoot.addEventListener('ready', () => {
        // widget ready to use
      })
      commentsRoot.dispatchEvent(
        new CustomEvent('init', {detail: {appId: 123}})
      )
    </script>
  </body>
</html>
```

## Возможные проблемы

Помимо перечисленных выше преимуществ и особенностей, архитектура микро-фронтендов имеет ряд проблемных вопросов, которые необходимо учитывать как при выборе архитектуры того или иного решения, так и при дальнейшей реализации этой архитектуры.

### Совместимость UI

Необходимо обеспечить согласованность внешнего вида и поведения UI в микро-фронтендах для соблюдения визуальной интеграции между микро-приложениями.

#### Что можно сделать

Вынести общую функциональность в библиотеки UI компонентов и вспомогательных утилит, которые могут быть использованы всеми микро-приложениями, чтобы минимизировать дублирование кода, а также упростить поддержку и обновление интерфейсов.

### Синхронизация данных

Невозможно использовать использовать общее состояние, чтобы максимально изолировать микро-приложения друг от друга.

#### Что можно сделать

Проектировать масштабируемые API для взаимодействия между различными микро-приложениями по задокументированным контрактам.

### Изоляция CSS-стилей

Микро-приложения в горизонтальной архитектуре зачастую работают в контексте одной страницы браузера, поэтому глобальная видимость CSS-стилей может нарушать инкапсуляцию и модульность, что ведет к конфликтам и непредсказуемым ошибкам в отображении.

#### Что можно сделать

Использовать методологии, такие как BEM, и технологии, включая [CSS-модули](https://github.com/css-modules/css-modules), [CSS-in-JS](https://en.wikipedia.org/wiki/CSS-in-JS) и [Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM), чтобы изолировать стили каждого микро-приложения и предотвратить конфликты, тем самым обеспечивая надежную инкапсуляцию и модульность.

### Изоляция JavaScript

JavaScript скрипты, выполняемые в контексте хост-приложения, могут взаимодействовать с контентом и данными микро-приложений, что вызывает уязвимости в безопасности и возможность утечек пользовательских данных.

#### Что можно сделать

Использовать iframe для интеграции микро-приложений, чтобы обеспечить полную изоляцию, исключить доступ к DOM элементам и предотвратить выполнение скриптов хост-приложения в контексте микро-приложений, усиливая таким образом безопасность взаимодействия.

### Изоляция данных

Изоляция third-party cookie и хранилищ для кросс-доменных iframe при наличии браузерных ограничений, например [Intelligent Tracking Prevention](https://webkit.org/blog/9521/intelligent-tracking-prevention-2-3/).

#### Что можно сделать

Явно проверять и запрашивать разрешение пользователя для доступа к third-party данным через [Storage Access API](https://developer.mozilla.org/en-US/docs/Web/API/Storage_Access_API). Также возможно хранить данные в cookie и стораджах в контексте хост-приложения, что возможно в случае комбинированного встраивания через JavaScript интерфейс c iframe под капотом.

### Увеличение количества зависимостей и дублирование

При использовании одинакового фреймворка микро-приложениями возможно дублирование кода фреймворка, и также каждый микро-фронтенд добавляет дополнительные HTTP-запросы для загрузки своих ресурсов, что может повлиять на производительность приложения.

#### Что можно сделать

Используйте асинхронную загрузку ([Lazy Loading](https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading)) микро-приложений, а также выносите общий код в удаленные модули ([Module Federation](https://webpack.js.org/concepts/module-federation/)), чтобы пользователи могли быстрее получить доступ к основному контенту, в то время как дополнительные функции догружаются в фоновом режиме.

### Усложнение инфраструктуры

Разделение монолитов на множество небольших микро-приложений приводит к увеличению количества репозиториев, конвейеров доставки, инфраструктуры, которые необходимо поддерживать.

#### Что можно сделать

Внедрить автоматизацию операций и процессов разработки, тестирования и доставки для обеспечения и управления дополнительной необходимой инфраструктурой.

### Усложнение стека и процессов

Автономия разработки в рамках микро-фронтендов позволяет командам принимать решения независимо, что может привести к увеличению количества используемых технологий, инструментов и методологий.

#### Что можно сделать

Разработайте общие стандарты и практики, включая стиль кодирования, архитектурные паттерны и технологические стеки, что поможет облегчить интеграцию микро-приложений и упростит совместную работу команд.

### Увеличение bus factor

Разделение сотрудников на много небольших команд, а также разнообразие подходов и инструментов может увеличить риски, связанные с таким понятием, как "bus factor" (уязвимость проекта, связанная с потерей ключевых сотрудников), а также затруднить взаимозаменяемость разработчиков.

#### Что можно сделать

Поддерживайте высокий уровень документации и обеспечте перекрестное ревью кода. Создавайте кросс-функциональные команды, где члены разных команд могут быть вовлечены в другие проекты и осведомлены о ключевых аспектах различных микро-приложений, способствует повышению гибкости и устойчивости команд.

## Заключение

Рост сложности приложений и необходимость быстрой и качественной разработки привели к развитию микро-фронтендов как способа управления большими проектами, облегчая обновление, поддержку и масштабирование.

Архитектура микро-фронтендов позволяет разбивать веб-приложения на независимые компоненты, способствуя модульности, гибкости и параллельной работе команд. Также существуют проблемы, такие как увеличение количества загружаемых ресурсов и зависимостей, изоляция приложений и некоторые сложности в управлении.

Тем не менее, микро-фронтенды представляют собой важный этап эволюции разработки веб-приложений, позволяя компаниям более эффективно масштабировать свои проекты и команды. Несмотря на сложности, данный подход обещает большую гибкость и скорость разработки, а также упрощает поддержку и обновление продуктов.

Для дальнейшего изучения обратите внимание на дополнительные материалы:

* [Curated list of resources about Micro frontends](https://github.com/billyjov/microfrontend-resources)
* [Micro Frontends by Michael Geers](https://micro-frontends.org)
* [Top 10 Micro Frontend Anti-Patterns](https://dev.to/florianrappl/top-10-micro-frontend-anti-patterns-3809)
